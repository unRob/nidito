#!/usr/bin/env bash

CONFIG_FILE="${CONFIG_FILE:-../config.yml}"

case $1 in
  --list)
    # continue
    ;;
  --host)
    echo "{}"
    exit 0
    ;;
  *)
    >&2 echo "unknown args: $*"
    exit 2
esac

function config_get () {
  gcy get "$CONFIG_FILE" "$1"
}

function ymlq () {
  jq -c "$1" <(echo "$nodes")
}

function filter () {
  local filter reduce
  filter="$1"
  reduce="${2:-keys}"
  ymlq "with_entries(select(.value.$filter)) | $reduce"
}

function node_tags () {
  local prop
  prop="$1"
  ymlq "to_entries | reduce .[] as \$n ({}; . * { (\$n.value.${prop}): ((.[\$n.value.${prop}] // []) + [\$n.key]) } ) | to_entries | map({ (\"${prop}_\"+(.key | gsub(\"\\\\W\"; \"_\"))): { hosts: .value } }) | add"
}


# decrypt once
nodes=$(config_get nodes)

( cat <<JSON
{
  "_meta": { 
    "hostvars": $(ymlq 'with_entries({key: .key, value: ({node: .value} + .value._ansible) })')
  }
  ,
  "dns_nameserver": {
    "hosts": $(filter 'dns.enabled'),
    "vars": {
      "dns": {
        "servers": $(filter 'dns.enabled' 'to_entries | sort_by(.value.dns.mode != "leader") | map({ name: .key, address: .value.address })'),
        "hosts": $(filter 'reachability != "gateway"' 'to_entries | map({ name: .key, address: .value.address })'),
        "consul_servers": $(filter 'consul' 'map(.address)')
      }
    }
  },
  "all": {
    "hosts": $(ymlq keys),
    "vars": {
      "nidito":{
        "dns": $(config_get dns),
        "consul": $(config_get consul),
        "nomad": $(config_get nomad),
        "networks": $(config_get networks),
        "filebeat": $(config_get filebeat),
        "dns_servers": $(filter 'dns.enabled' 'to_entries | sort_by(.value.dns.mode != "leader") | map(.value.address)' )
      }
    }
  },
  "consul_server": {
    "hosts": $(filter 'consul')
  },
  "nomad_server": {
    "hosts": $(filter 'nomad')
  },
  "ungrouped": {
    "children": []
  }
}
JSON

# add dynamic groups for nodes with different properties
node_tags reachability
node_tags platform


) | jq -s ". | add"
